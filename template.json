{
    "C++ Competitive Template": {
        "prefix": "cpp",
        "body": [
            "/**",
            " *   author: Parinya Aobaun",
            " *   created: ${CURRENT_YEAR}-${CURRENT_MONTH}-${CURRENT_DATE} ${CURRENT_HOUR}:${CURRENT_MINUTE}",
            "**/",
            "#pragma GCC optimize(\"Ofast,unroll-loops\")",
            "#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,avx,avx2,fma\")",
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "",
            "#define fastio ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);",
            "#define int long long",
            "#define ull unsigned long long",
            "#define ld long double",
            "#define pb push_back",
            "#define all(v) v.begin(), v.end()",
            "#define rall(v) v.rbegin(), v.rend()",
            "#define pii pair<int, int>",
            "#define vi vector<int>",
            "#define fi first",
            "#define se second",
            "",
            "const int MOD = 1e9+7;",
            "const int INF = 1e18;",
            "",
            "// Utility Functions",
            "template<typename T> bool chmin(T& a, T b) { return b < a ? a = b, 1 : 0; }",
            "template<typename T> bool chmax(T& a, T b) { return b > a ? a = b, 1 : 0; }",
            "",
            "int gcd(int a, int b) { return b ? gcd(b, a % b) : a; }",
            "int lcm(int a, int b) { return a / gcd(a, b) * b; }",
            "",
            "// Sieve of Eratosthenes",
            "vector<int> sieve(int max_limit) {",
            "    vector<int> is_prime(max_limit + 1, 1);",
            "    is_prime[0] = is_prime[1] = 0;",
            "    for(int i = 2; i * i <= max_limit; ++i) {",
            "        if(is_prime[i]) {",
            "            for(int j = i * i; j <= max_limit; j += i)",
            "                is_prime[j] = 0;",
            "        }",
            "    }",
            "    return is_prime;",
            "}",
            "",
            "// Factorization",
            "vector<pair<int, int>> factorize(int n) {",
            "    vector<pair<int, int>> factors;",
            "    for(int i = 2; i * i <= n; ++i) {",
            "        if(n % i == 0) {",
            "            int count = 0;",
            "            while(n % i == 0) {",
            "                n /= i;",
            "                count++;",
            "            }",
            "            factors.emplace_back(i, count);",
            "        }",
            "    }",
            "    if(n > 1) factors.emplace_back(n, 1);",
            "    return factors;",
            "}",
            "",
            "// Combinatorics",
            "int power(int a, int b, int mod = MOD) {",
            "    int res = 1;",
            "    a %= mod;",
            "    while(b > 0) {",
            "        if(b & 1) res = res * a % mod;",
            "        a = a * a % mod;",
            "        b >>= 1;",
            "    }",
            "    return res;",
            "}",
            "",
            "int inv(int a, int mod = MOD) {",
            "    return power(a, mod - 2, mod);",
            "}",
            "",
            "int nCr(int n, int r, int mod = MOD) {",
            "    if(r > n) return 0;",
            "    vector<int> fac(n + 1, 1);",
            "    for(int i = 2; i <= n; ++i) fac[i] = fac[i-1] * i % mod;",
            "    return fac[n] * inv(fac[r], mod) % mod * inv(fac[n - r], mod) % mod;",
            "}",
            "",
            "// Graph Algorithms",
            "typedef vector<vector<pii>> graph;",
            "",
            "// BFS",
            "vector<int> bfs(const graph &g, int start) {",
            "    int n = g.size();",
            "    vector<int> distance(n, INF);",
            "    queue<int> q;",
            "    q.push(start);",
            "    distance[start] = 0;",
            "    while(!q.empty()) {",
            "        int u = q.front(); q.pop();",
            "        for(auto &[v, w] : g[u]) {",
            "            if(distance[v] == INF) {",
            "                distance[v] = distance[u] + 1;",
            "                q.push(v);",
            "            }",
            "        }",
            "    }",
            "    return distance;",
            "}",
            "",
            "// Dijkstra",
            "vector<int> dijkstra(const graph &g, int start) {",
            "    int n = g.size();",
            "    vector<int> distance(n, INF);",
            "    priority_queue<pair<int, int>, vector<pair<int, int>>, std::greater<pair<int, int>>> pq;",
            "    pq.push({0, start});",
            "    distance[start] = 0;",
            "    while(!pq.empty()) {",
            "        auto [dist, u] = pq.top(); pq.pop();",
            "        if(dist > distance[u]) continue;",
            "        for(auto &[v, w] : g[u]) {",
            "            if(distance[v] > distance[u] + w) {",
            "                distance[v] = distance[u] + w;",
            "                pq.push({distance[v], v});",
            "            }",
            "        }",
            "    }",
            "    return distance;",
            "}",
            "",
            "// Dynamic Programming",
            "int dp_fib(int n) {",
            "    if(n <= 1) return n;",
            "    vector<int> dp(n+1, 0);",
            "    dp[0] = 0; dp[1] = 1;",
            "    for(int i = 2; i <= n; ++i)",
            "        dp[i] = dp[i-1] + dp[i-2];",
            "    return dp[n];",
            "}",
            "",
            "signed main() {",
            "    fastio;",
            "    ",
            "    // Your code starts here",
            "",
            "    return 0;",
            "}"
        ],
        "description": "Optimized Template for C++ Competitive Programming with Math, DP, and Graph Utilities"
    }
}